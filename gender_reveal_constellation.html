<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover"/> 
    <meta name="color-scheme" content="dark only">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Alegreya+SC&display=swap" rel="stylesheet">
    <title>Constellation Gender Reveal</title>
    <link href="main.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="main_landscape.css" media="screen and (orientation: landscape) and (max-width: 1023px)">

</head>
<body>
    <div class="stars-container" id="starsContainer"></div>
    <canvas class="constellation-canvas" id="constellationCanvas"></canvas>
    
    <div class="instructions" id="instructions">
        Click the glowing stars to reveal the secret for the Baby...
    </div>
    
    <div class="reveal-container" id="revealContainer">
        <div class="gender-text" id="genderText"></div><br>
        <div class="baby-text" id="babyText">The stars revealed the secret for the Baby!</div>
    </div>
     <div id="progress-indicator">
        <div id="progress-text">Click the glowing star to begin...</div>
        <div id="constellation-name"></div>
    </div>
    <script>
        // Configuration - Change these values to customize
        const CONFIG = {
            numBackgroundStars: 150
        };

        // Constellation data - complete Orion formation
        const CONSTELLATIONS = {
            orion: {
                name: 'Orion',
                gender: 'BOY',
                stars: [
                    // Main clickable stars in order
                    { name: 'Meissa', x: 0.4, y: 0.45 },          
                    { name: 'Betelgeuse', x: 0.53, y: 0.388 },      
                    { name: 'Bellatrix', x: 0.599, y: 0.479 },      
                    { name: 'Alnitak', x: 0.558, y: 0.656 },        
                    { name: 'Mintaka', x: 0.493, y: 0.701 },         
                    { name: 'Saiph', x: 0.449, y: 0.911 },           
                    { name: 'Rigel', x: 0.673, y: 0.867 }           
                ],
                additionalStars: [
                    // Revealed after main constellation
                    { name: 'Theta1 Orionis', x: 0.277, y: 0.125 },  
                    { name: 'Iota Orionis', x: 0.294, y: 0.262 },    
                    { name: 'Pi1 Orionis', x: 0.356, y: 0.388 },     
                    { name: 'Pi2 Orionis', x: 0.348, y: 0.1 },    
                    { name: 'Pi3 Orionis (Tabit)', x: 0.323, y: 0.251 }, 
                    { name: 'Pi4 Orionis', x: 0.76, y: 0.38 },     
                    { name: 'Pi5 Orionis', x: 0.78, y: 0.40 },     
                    { name: 'Pi6 Orionis', x: 0.79, y: 0.46 },      
                    { name: 'Pi6 Orionis', x: 0.76, y: 0.57 },                          
                    { name: 'Pi6 Orionis', x: 0.74, y: 0.58 }      

                ],
                extraLines: [
                    [0, 4], // main: 1-5 (Meissa-Mintaka)
                    [3, 6], // main: 4-7 (Alnitak-Rigel)
                    [2, 14],
                    [7, 8], // additional: 1-4 (Theta1 Orionis - Pi2 Orionis)
                    [8, 9], // additional: 4-5 (Pi2 Orionis - Pi3 Orionis)
                    [10, 11],   // additional: 2-3 (Iota Orionis - Pi1 Orionis)
                    [11, 8],  // additional: 3-5 (Pi1 Orionis - Pi3 Orionis)
                    [12, 13], // additional: 6-7 (Pi4 Orionis - Pi5 Orionis)
                    [13, 14], // additional: 7-8 (Pi5 Orionis - Pi6 Orionis)
                    [14, 15], // additional: 8-9 (Pi6 Orionis - Pi6 Orionis)
                    [15, 16],  // additional: 9-10 (Pi6 Orionis - Pi6 Orionis)
                    [0, 9]  // additional: 9-10 (Pi6 Orionis - Pi6 Orionis)

                ]
            },
            andromeda: {
                name: 'Andromeda',
                gender: 'GIRL', 
                stars: [
                    { name: 'Alpheratz', x: 0.284, y: 0.339 },       // Head
                    { name: 'Mirach', x: 0.453, y: 0.391 },          // Hip
                    { name: 'Almach', x: 0.594, y: 0.408 },          // Left foot
                    { name: 'Delta And', x: 0.649, y: 0.377 },      // Right side
                    { name: 'Mu And', x: 0.635, y: 0.547 },          // Right arm
                    { name: 'Nu And', x: 0.548, y: 0.534 },         // Left arm
                    { name: 'Upsilon And', x: 0.491, y: 0.542 },      // Right foot
                    { name: 'Upsilon And', x: 0.412, y: 0.668 }      // Right foot

                ],
                additionalStars: [
                    // Revealed after main constellation
                    { name: '', x: 0.184, y: 0.230 },  
                    { name: '', x: 0.219, y: 0.392 },    
                    { name: '', x: 0.269, y: 0.370 },     
                    { name: '', x: 0.603, y: 0.238 },    
                    { name: '', x: 0.690, y: 0.353 },     
                    { name: '', x: 0.792, y: 0.329 },     
                    { name: '', x: 0.844, y: 0.372 },      
                    { name: '', x: 0.592, y: 0.819 },                          
                    { name: '', x: 0.427, y: 0.785 }
                ],
                 extraLines: [
                    [0, 8], 
                    [9, 10], 
                    [10, 0],
                    [11,3],
                    [12,3],
                    [13,12],
                    [14,13],
                    [15,4],
                    [16,7]
                ]      
            }
        };
        // Global variables for params and surname
        let timeout;
        var color1 = '#ff95c8';
        var color2 = '#0128A5FF';
        var color3 ='#969696';
        var colortxt1 = '#ff0b9a';
        var colortxt2= '#88BEFFFF';
        var colortxt3= '#000000';
        //Select the background color
        var color =color1;
        //Select the text color
        var colortxt = colortxt1;
        var gendertext1 = "It is a Girl!";
        var gendertext2 = "It is a Boy!";
        var gendertext3= "It is a Demo!";
        //Select the gender text
        var gendertext = gendertext1;
        var soundHandle = new Audio();
        var triggered=false;
        var nosound=true;
        let params = new URLSearchParams(window.location.search.slice(1));
        let surname = params.get('surname');
        // Set constellation based on gendertext
        if (gendertext.toLowerCase().includes('boy')) {
            CONFIG.constellation = 'orion';
        } else if (gendertext.toLowerCase().includes('girl')) {
            CONFIG.constellation = 'andromeda';
        }
        // Update instructions with family name or fallback
        if (surname === null || surname.replace(/\s/g, '').length === 0) {
            surname= 'the Baby';
        } else{
            surname = 'the Baby ' + surname;
        }
        class ConstellationReveal {
            constructor() {
                this.canvas = document.getElementById('constellationCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.starsContainer = document.getElementById('starsContainer');
                this.instructions = document.getElementById('instructions');
                this.revealContainer = document.getElementById('revealContainer');
                
                this.currentConstellation = CONSTELLATIONS[CONFIG.constellation];
                this.currentStarIndex = 0;
                this.constellationStars = [];
                this.lines = [];
                this.isRevealed = false;
                
                this.init();
            }

            drawExtraLines() {
                const { extraLines } = this.currentConstellation;
                if (!extraLines) return;
                const allStars = [...this.constellationStars, ...(this.additionalStars || [])];
                extraLines.forEach(([fromIdx, toIdx]) => {
                    this.drawLine(allStars[fromIdx], allStars[toIdx]);
                });
            }

            revealAdditionalStars() {
                if (this.additionalStars) {
                    this.additionalStars.forEach((star, index) => {
                        setTimeout(() => {
                            star.style.visibility = 'visible';
                            star.style.opacity = '0.7';
                            star.classList.add('additional');
                            // Draw extra lines after all additional stars are visible
                            if (index === this.additionalStars.length - 1) {
                                setTimeout(() => {
                                    this.drawExtraLines();
                                    // Show the PNG overlay below the stars
                                    this.showOrionOverlay(false);
                                }, 300);
                            }
                        }, index * 200);
                    });
                }
            }

            showOrionOverlay(updateOnly = false) {
                let img = document.getElementById('overlay-img');
                const canvasRect = this.canvas.getBoundingClientRect();
                if (img && updateOnly) {
                    img.style.left = canvasRect.left + 'px';
                    img.style.top = canvasRect.top + 'px';
                    img.style.width = canvasRect.width + 'px';
                    img.style.height = canvasRect.height + 'px';
                    return;
                }
                if (img) img.remove();
                img = document.createElement('img');
                img.src = 'overlay.png';
                img.id = 'overlay-img';
                img.style.position = 'absolute';
                img.style.left = canvasRect.left + 'px';
                img.style.top = canvasRect.top + 'px';
                img.style.width = canvasRect.width + 'px';
                img.style.height = canvasRect.height + 'px';
                img.style.zIndex = 8; // below stars (z-index:10)
                img.style.pointerEvents = 'none';
                img.style.opacity = '0'; // Start fully transparent
                img.style.transition = 'opacity 1.5s ease'; // Animate fade-in
                document.body.insertBefore(img, this.starsContainer);
                setTimeout(() => { img.style.opacity = '0.5'; }, 50);
            }
           
            init() {
                // Set additional star color to colortxt at the beginning
                document.documentElement.style.setProperty('--additional-star-color', colortxt);
                this.handleResizeOrOrientationChange();
                this.instructions.textContent = 'Click the glowing stars to reveal the secret for ' + surname + '...';
                // Show first star
                window.addEventListener('resize', () => this.handleResizeOrOrientationChange());
                window.addEventListener('orientationchange', () => this.handleResizeOrOrientationChange());
            }

            handleResizeOrOrientationChange() {
               clearTimeout(timeout);
                timeout = setTimeout(() => {
                        this.setupCanvas();
                        this.createBackgroundStars();
                        this.createConstellationStars();
                        this.highlightCurrentStar();
                    }, 500);
                 
            }

            setupCanvas() {
                const isLandscape = window.matchMedia('(orientation: landscape) and (max-width: 1023px)').matches;
                // Use visualViewport for mobile toolbars if available
                let W = window.visualViewport ? window.visualViewport.width : window.innerWidth;
                let H = window.visualViewport ? window.visualViewport.height : window.innerHeight;
                if (window.screen && window.screen.availWidth && window.screen.availHeight) {
                    W = Math.min(W, window.screen.availWidth);
                    H = Math.min(H, window.screen.availHeight);
                }

                const cs = getComputedStyle(document.documentElement);
                const safeLeft = parseFloat(cs.getPropertyValue('--safe-left')) || 0;
                const safeTop  = parseFloat(cs.getPropertyValue('--safe-top'))  || 0;

                let size, left, top;

                if (isLandscape) {
                    W = Math.max(window.innerWidth, window.innerHeight);
                    H = Math.min(window.innerWidth, window.innerHeight);
                    // square that fits half the width or full height, with small padding
                    size = Math.min(W * 0.5, H) * 0.95;
                    // center in LEFT half: center at 25% of width
                    left = safeLeft + (W * 0.25) - (size / 1.8);
                    top  = safeTop  + (H * 0.5)  - (size / 1.8);

                    this.canvas.style.transform = 'none';   // kill any lingering center transform
                } else {
                    size = Math.min(W, H) * 0.95;
                    left = (W * 0.5) - (size / 1.8);
                    top  = (H * 0.5) - (size / 2);
                    this.canvas.style.transform = 'none';   // or keep portrait centering via CSS
                }

                this.canvas.width = size;
                this.canvas.height = size;
                Object.assign(this.canvas.style, {
                    position: 'fixed',
                    width:  size + 'px',
                    height: size + 'px',
                    left:   left + 'px',
                    top:    top  + 'px'
                });

                // If portrait, move canvas 20% down
                /* if (window.innerHeight > window.innerWidth) {
                    this.canvas.style.top = (window.innerHeight * 0.2) + 'px';
                    this.canvas.style.left = ((window.innerWidth - size) / 2) + 'px';
                }  */
                // Make starsContainer full screen for background
                this.starsContainer.style.width = '100vw';
                this.starsContainer.style.height = '100vh';
                this.starsContainer.style.position = 'absolute';
                this.starsContainer.style.left = '0';
                this.starsContainer.style.top = '0';
            }

            createBackgroundStars() {
                // Remove previous background stars if resizing
                const existingStars = this.starsContainer.querySelectorAll('.background-star');
                existingStars.forEach(star => star.remove());
                for (let i = 0; i < CONFIG.numBackgroundStars; i++) {
                    const star = document.createElement('div');
                    star.className = 'star background-star';
                    star.style.left = Math.random() * 100 + '%';
                    star.style.top = Math.random() * 100 + '%';
                    star.style.animationDelay = Math.random() * 2 + 's';
                    star.style.animationDuration = (1 + Math.random() * 2) + 's';
                    this.starsContainer.appendChild(star);
                }
            }

            createConstellationStars() {
                const margin = 0.00;
                // Get canvas offset for correct placement
                const canvasRect = this.canvas.getBoundingClientRect();
                const leftOffset = canvasRect.left;
                const topOffset = canvasRect.top;
                // Additional stars
                if (this.currentConstellation.additionalStars) {
                    if (this.additionalStars && this.additionalStars.length === this.currentConstellation.additionalStars.length) {
                        this.currentConstellation.additionalStars.forEach((starData, index) => {
                            const star = this.additionalStars[index];
                            if (star) {
                                star.style.left = ((margin + starData.x * (1 - 2 * margin)) * this.canvas.width + leftOffset) + 'px';
                                star.style.top = ((margin + starData.y * (1 - 2 * margin)) * this.canvas.height + topOffset) + 'px';
                            }
                        });
                    } else {
                        if (this.additionalStars) {
                            this.additionalStars.forEach(star => star.remove());
                        }
                        this.additionalStars = [];
                        this.currentConstellation.additionalStars.forEach((starData, index) => {
                            const star = document.createElement('div');
                            star.className = 'star constellation-star additional';
                            star.style.left = ((margin + starData.x * (1 - 2 * margin)) * this.canvas.width + leftOffset) + 'px';
                            star.style.top = ((margin + starData.y * (1 - 2 * margin)) * this.canvas.height + topOffset) + 'px';
                            star.style.visibility = 'hidden';
                            star.style.opacity = '0';
                            this.starsContainer.appendChild(star);
                            this.additionalStars.push(star);
                        });
                    }
                }
                // Reposition and redraw existing constellation stars
                if (this.constellationStars.length === this.currentConstellation.stars.length) {
                    // Only update position and visibility
                    this.currentConstellation.stars.forEach((starData, index) => {
                        const star = this.constellationStars[index];
                        if (star) {
                            star.style.left = ((margin + starData.x * (1 - 2 * margin)) * this.canvas.width + leftOffset) + 'px';
                            star.style.top = ((margin + starData.y * (1 - 2 * margin)) * this.canvas.height + topOffset) + 'px';
                        }
                    });
                    // Redraw lines between completed stars
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    setTimeout(() =>{
                        for (let i = 1; i < this.constellationStars.length; i++) {
                            if (this.constellationStars[i].classList.contains('completed')) {
                                this.drawLine(this.constellationStars[i - 1], this.constellationStars[i]);
                            }
                        }
                        if (this.isRevealed) {
                            this.drawExtraLines();
                            this.showOrionOverlay(true);
                        }
                    },500);

                } else {
                    // Initial creation
                    this.constellationStars.forEach(star => star.remove());
                    this.constellationStars = [];
                    this.currentConstellation.stars.forEach((starData, index) => {
                        const star = document.createElement('div');
                        star.className = 'star constellation-star';
                        star.style.left = ((margin + starData.x * (1 - 2 * margin)) * this.canvas.width + leftOffset) + 'px';
                        star.style.top = ((margin + starData.y * (1 - 2 * margin)) * this.canvas.height + topOffset) + 'px';
                        star.style.visibility = 'hidden';
                        star.style.opacity = '0';
                        star.dataset.index = index;
                        const touchHint = document.createElement('div');
                        touchHint.className = 'touch-hint';
                        touchHint.textContent = 'Touch here';
                        star.appendChild(touchHint);
                        star.addEventListener('click', (e) => this.handleStarClick(e, index));
                        this.starsContainer.appendChild(star);
                        this.constellationStars.push(star);
                    });
                     
                }
               
               
            }

            highlightCurrentStar() {
                if (this.currentStarIndex < this.constellationStars.length) {
                    // Clear all current highlights and hints first
                    this.constellationStars.forEach(star => {
                        star.classList.remove('current');
                        const hint = star.querySelector('.touch-hint');
                        if (hint) hint.classList.remove('show');
                    });
                    
                    // Clear any existing hint timer
                    if (this.hintTimer) {
                        clearTimeout(this.hintTimer);
                    }
                    
                    // Show and highlight current star
                    const currentStar = this.constellationStars[this.currentStarIndex];
                    currentStar.style.visibility = 'visible';
                    currentStar.style.opacity = '1';
                    currentStar.classList.add('current');
                    
                    // Set timer for touch hint (random between 3-5 seconds)
                    const hintDelay = 3000 + Math.random() * 2000; // 3-5 seconds
                    this.hintTimer = setTimeout(() => {
                        const hint = currentStar.querySelector('.touch-hint');
                        if (hint && currentStar.classList.contains('current')) {
                            hint.classList.add('show');
                        }
                    }, hintDelay);
                    
                }
            }

            handleStarClick(event, clickedIndex) {
                
                if (this.isRevealed || clickedIndex !== this.currentStarIndex) {
                    return;
                }
                
                // Clear hint timer
                if (this.hintTimer) {
                    clearTimeout(this.hintTimer);
                }
                this.updateProgress(clickedIndex);
                const star = this.constellationStars[clickedIndex];
                this.createSparkleEffect(star);
                // Hide touch hint
                const hint = star.querySelector('.touch-hint');
                if (hint) {
                    hint.classList.remove('show');
                    hint.style.display = 'none';
                }
                
                // Mark star as completed
                star.classList.remove('current');
                star.classList.add('completed');
                star.style.visibility = 'visible';
                star.style.opacity = '1';
                
                // Draw line to previous star
                if (this.currentStarIndex > 0) {
                    this.drawLine(
                        this.constellationStars[this.currentStarIndex - 1],
                        star
                    );
                }
                
                this.currentStarIndex++;
                
                // Hide instructions after first click
                if (this.currentStarIndex === 1) {
                    this.instructions.classList.add('hidden');
                }
                
                // Check if main constellation is complete
                if (this.currentStarIndex >= this.constellationStars.length) {
                    this.revealAdditionalStars();
                    setTimeout(() => {
                        this.completeReveal();
                    }, 1000);
                    // Constellation pulse
                    this.constellationStars.forEach((star, index) => {
                    setTimeout(() => {
                        this.pulseStarFinal(star);
                    }, index * 100);
            });
                } else {
                    // Show next star
                    setTimeout(() => {
                        this.highlightCurrentStar();
                    }, 100);
                }
            }

           drawLine(fromStar, toStar) {
            // Draw lines using the DOM position of the stars, relative to the canvas
            const canvasRect = this.canvas.getBoundingClientRect();
            const fromRect = fromStar.getBoundingClientRect();
            const toRect = toStar.getBoundingClientRect();
            const fromX = (fromRect.left - canvasRect.left) + fromRect.width / 2;
            const fromY = (fromRect.top - canvasRect.top) + fromRect.height / 2;
            const toX = (toRect.left - canvasRect.left) + toRect.width / 2;
            const toY = (toRect.top - canvasRect.top) + toRect.height / 2;

            // Create gradient along the line
            const gradient = this.ctx.createLinearGradient(fromX, fromY, toX, toY);
            gradient.addColorStop(0.0, "rgba(255, 215, 0, 0)");     // transparent at start
            gradient.addColorStop(0.3, "rgba(255, 215, 0, 0.6)");   // fade in
            gradient.addColorStop(0.5, "rgba(255, 215, 0, 1)");     // brightest at middle
            gradient.addColorStop(0.7, "rgba(255, 215, 0, 0.6)");   // fade out
            gradient.addColorStop(1.0, "rgba(255, 215, 0, 0)");     // transparent at end

            this.ctx.strokeStyle = gradient;
            this.ctx.lineWidth = 3;

            this.ctx.beginPath();
            this.ctx.moveTo(fromX, fromY);
            this.ctx.lineTo(toX, toY);
            this.ctx.stroke();
        }
 // Create sparkle effect
        createSparkleEffect(star) {
            const rect = star.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            for (let i = 0; i < 8; i++) {
                const sparkle = document.createElement('div');
                sparkle.className = 'cosmic-burst';
                sparkle.style.left = centerX + (Math.random() - 0.5) * 40 + 'px';
                sparkle.style.top = centerY + (Math.random() - 0.5) * 40 + 'px';
                document.body.appendChild(sparkle);
                
                this.animateSparkle(sparkle);
            }
        }

        // Animate sparkle effect
        animateSparkle(sparkle) {
            let scale = 1;
            let opacity = 1;
            
            const animate = () => {
                scale += 0.1;
                opacity -= 0.05;
                sparkle.style.transform = `scale(${scale})`;
                sparkle.style.opacity = Math.max(opacity, 0);
                
                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    sparkle.remove();
                }
            };
            animate();
        }
        // Pulse star final effect
        pulseStarFinal(star) {
            let scale = 1.2;
            let pulses = 0;
            const maxPulses = 6;
            
            const pulse = () => {
                scale = scale === 1.2 ? 1.8 : 1.2;
                star.style.transform = `scale(${scale})`;
                pulses++;
                
                if (pulses < maxPulses) {
                    setTimeout(pulse, 200);
                }
            };
            pulse();
        }
        // Update progress indicator
        updateProgress(clickedIndex) {
            const progressIndicator = document.getElementById('progress-indicator');
            const progressText = document.getElementById('progress-text');
            
            progressIndicator.style.opacity = '1';
            
            if (clickedIndex + 1 < this.constellationStars.length) {
                progressText.textContent = `${clickedIndex+1}/${this.constellationStars.length} stars clicked`;
            } else {
                progressText.textContent = 'Constellation complete!';
            }
        }
            completeReveal() {
                this.isRevealed = true;
                // Create shooting stars animation
                this.createShootingStars();
                // Show reveal message after short delay
                setTimeout(() => {
                    const genderText = document.getElementById('genderText');
                    genderText.textContent = gendertext;
                    genderText.classList.add('animate');
                    // Set solid color for genderText using color variable
                    genderText.style.background = '';
                    genderText.style.backgroundClip = '';
                    genderText.style.webkitBackgroundClip = '';
                    genderText.style.webkitTextFillColor = '';
                    genderText.style.textFillColor = '';
                    genderText.style.color = colortxt;
                    this.revealContainer.classList.add('show');
                    // Set babyText with surname if set, otherwise fallback
                    const babyText = document.getElementById('babyText');                    
                   
                    if (gendertext==gendertext2){
                        babyText.textContent = surname + ' will be Strong and Bold — just like Orion, the great hunter in the sky';
                    }else {
                        babyText.textContent = surname + ' will be Graceful and Radiant — like Andromeda, the princess of the stars';

                    }
                    document.getElementById('progress-indicator').style.opacity = '0';

                }, 1000);
            }

            createShootingStars() {
                // Get canvas position and size
                const canvasRect = this.canvas.getBoundingClientRect();
                for (let i = 0; i < 100; i++) {
                    setTimeout(() => {
                        const shootingStar = document.createElement('div');
                        shootingStar.className = 'shooting-star';
                        // Randomize which edge to start from (top, left, right)
                        let edge = Math.floor(Math.random() * 3);
                        edge = 1;
                        let startX, startY, endX, endY;
                        if (edge === 0) { // Top edge
                            startX = canvasRect.left + Math.random() * canvasRect.width;
                            startY = canvasRect.top - 30;
                            endX = startX + 100 + Math.random() * 100;
                            endY = canvasRect.top + canvasRect.height + 30;
                        } else if (edge === 1) { // Left edge
                            startX = canvasRect.left - 30;
                            startY = canvasRect.top + Math.random() * canvasRect.height;
                            endX = canvasRect.left + canvasRect.width + 30;
                            endY = startY + 100 + Math.random() * 100;
                        } else { // Right edge
                            startX = canvasRect.left + canvasRect.width + 30;
                            startY = canvasRect.top + Math.random() * canvasRect.height;
                            endX = canvasRect.left - 30;
                            endY = startY - 100 - Math.random() * 100;
                        }
                        shootingStar.style.position = 'fixed';
                        shootingStar.style.left = startX + 'px';
                        shootingStar.style.top = startY + 'px';
                        shootingStar.style.width = '5px';
                        shootingStar.style.height = '5px';
                        shootingStar.style.background = 'white';
                        shootingStar.style.borderRadius = '50%';
                        shootingStar.style.zIndex = 15;
                        shootingStar.style.boxShadow = '0 0 15px white, 0 0 30px white';
                        shootingStar.animate([
                            { transform: `translate(0px, 0px)`, opacity: 1 },
                            { transform: `translate(${endX - startX}px, ${endY - startY}px)`, opacity: 0 }
                        ], {
                            duration: 900 + Math.random() * 400,
                            easing: 'linear',
                            fill: 'forwards'
                        });
                        document.body.appendChild(shootingStar);
                        setTimeout(() => {
                            shootingStar.remove();
                        }, 1200);
                    }, i * 50);
                }
            }
        }

        // Initialize the reveal when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new ConstellationReveal();
        });

    </script>
</body>
</html>